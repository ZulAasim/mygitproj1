name: Populate Release Notes with Changelog

on:
  release:
    types: [published] # This workflow runs only when a new release is published

jobs:
  update_release_notes:
    runs-on: ubuntu-latest

    permissions:
      contents: write # To checkout code and potentially push back CHANGELOG.md
      releases: write # Essential for creating/updating release notes

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Get full history for changelog tools
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install

      # IMPORTANT: This step assumes you manually ran 'npm run changelog'
      # and committed the updated CHANGELOG.md *before* creating the release.
      # If you want the workflow to *generate* it during the release,
      # uncomment and move the 'Generate Changelog' step from the previous workflow here.
      # Example if you want it generated by the workflow:
      # - name: Generate Changelog (during workflow)
      #   run: npm run changelog
      #   # Commit and push if changed (optional, but good for main branch consistency)
      # - name: Commit and push Changelog if updated
      #   run: |
      #     git config user.name "github-actions[bot]"
      #     git config user.email "github-actions[bot]@users.noreply.github.com"
      #     if ! git diff --quiet CHANGELOG.md; then
      #       git add CHANGELOG.md
      #       git commit -m "docs: Update CHANGELOG.md for release ${{ github.event.release.tag_name }} [skip ci]"
      #       git push origin HEAD:main
      #     else
      #       echo "CHANGELOG.md already up-to-date."
      #     fi


      - name: Extract Changelog Content for Release
        id: extract_changelog
        run: |
          # Get the tag name from the release event (e.g., 'v1.2.3')
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          
          # Remove 'v' prefix if present for parsing CHANGELOG.md
          VERSION=$(echo "${RELEASE_TAG}" | sed 's/^v//')
          
          # This sed command extracts the section for the specific version
          # It looks for the heading for the version and stops at the next heading.
          # Adjust the patterns if your CHANGELOG.md format differs significantly.
          # Assumes headings are '## [X.Y.Z]' or '## X.Y.Z'
          CHANGELOG_SECTION=$(sed -n "/^## \[*${VERSION}\]*/,/^## \[*[^]]*\]*\|^## [^\]]*$/ {
            /^## \[*${VERSION}\]*/! { /^## \[*[^]]*\]*\|^## [^\]]*$/! p }
          }" CHANGELOG.md | sed '1d; $d' | sed '/^[[:space:]]*$/d') # Remove first line (version itself) and any trailing empty lines

          # Fallback if no specific section is found (e.g., first release)
          if [ -z "${CHANGELOG_SECTION}" ]; then
              echo "No specific changelog section found for ${VERSION}. Attempting to extract 'Unreleased' or full changelog."
              # You might adjust this fallback logic.
              # Example: Extracting everything after the last tag if no specific version section
              CHANGELOG_SECTION=$(conventional-changelog -p angular -r 1) # Get commits since last release for release notes
              if [ -z "${CHANGELOG_SECTION}" ]; then
                 echo "Warning: No changelog content found for the release."
                 CHANGELOG_SECTION="No changelog entries found for this release."
              fi
          fi

          # Escape newlines for multi-line output in GitHub Actions
          CHANGELOG_SECTION="${CHANGELOG_SECTION//'%'/'%25'}"
          CHANGELOG_SECTION="${CHANGELOG_SECTION//$'\n'/'%0A'}"
          CHANGELOG_SECTION="${CHANGELOG_SECTION//$'\r'/'%0D'}"
          
          echo "changelog_content=${CHANGELOG_SECTION}" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Update GitHub Release Body
        uses: github/gh-cli@v2 # Use the GitHub CLI action
        with:
          command: release edit ${{ github.event.release.tag_name }} --body-file <(echo "${{ steps.extract_changelog.outputs.changelog_content }}")
          # The above uses a process substitution to pass the content directly.
          # Alternatively, you could write the content to a temporary file first:
          # run: |
          #   echo "${{ steps.extract_changelog.outputs.changelog_content }}" > RELEASE_BODY.md
          #   gh release edit ${{ github.event.release.tag_name }} --body-file RELEASE_BODY.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # The token to authenticate with GitHub API
